#define constant G1_GEN_X = 0x0
#define constant G1_GEN_Y = 0x1
#define constant G1_GEN_Z = 0x2
#define constant OUTPUT_X = 0x3
#define constant OUTPUT_Y = 0x4
#define constant OUTPUT_Z = 0x5

// TODO remove unused range

#define constant TEMP_POINT_X = 0x6
#define constant TEMP_POINT_Y = 0x7
#define constant TEMP_POINT_Z = 0x8

#define constant TEMP0 = 0x9
#define constant TEMP1 = 0xa
#define constant TEMP2 = 0xb
#define constant TEMP3 = 0xc
#define constant TEMP3 = 0xd
#define constant TEMP4 = 0xe
#define constant TEMP5 = 0xf
#define constant TEMP6 = 0x10
#define constant TEMP7 = 0x11

#define constant ONE_VAL = 0x12
#define constant ONE_VAL_OFFSET_PLUS_16 = 0x370
#define constant VAL_12 = 0x13
#define constant VAL_12_OFFSET = 0x390
#define constant VAL_12_OFFSET_PLUS_16 = 0x3a0
#define constant ZERO_VAL = 0x14

#define constant G1_GEN_X_OFFSET = 0x00
#define constant G1_GEN_X_OFFSET_PLUS_32 = 0x20
#define constant G1_GEN_Y_OFFSET = 0x30
#define constant G1_GEN_Y_OFFSET_PLUS_32 = 0x50
#define constant G1_GEN_Z_OFFSET = 0x60
#define constant OUTPUT_X_OFFSET = 0x90
#define constant OUTPUT_X_OFFSET_PLUS_32 = 0xb0
#define constant OUTPUT_Y_OFFSET = 0xc0
#define constant OUTPUT_Y_OFFSET_PLUS_32 = 0xe0
#define constant OUTPUT_Z_OFFSET = 0xf0
#define constant OUTPUT_Z_OFFSET_PLUS_32 = 0x110
#define constant TEMP5_OFFSET = 0x02d0
#define constant TEMP5_OFFSET_PLUS_32 = 0x02f0

// OUTPUT_X <- OUTPUT_X / OUTPUT_Z
// OUTPUT_Y <- OUTPUT_Y / OUTPUT_Z
#define macro ToAffine() = takes(0) returns(0) {
    INVMOD_OUTPUT_Z()
    __mulmontx(OUTPUT_X, OUTPUT_X, OUTPUT_Z)
    __mulmontx(OUTPUT_Y, OUTPUT_Y, OUTPUT_Z)
}

#define macro InfCheck() = takes(0) returns(0) {
    // if OUTPUT_X == 0, OUTPUT_Y != 0, OUTPUT_Z == 0:
    //   OUTPUT <- (0, 1, 0) return (0, 0) from the contract

    [OUTPUT_X_OFFSET]
    mload
    [OUTPUT_X_OFFSET_PLUS_32]
    mload
    0xffffffffffffffffffffffffffffffff
    and
    // stack: OUTPUT_X (32 most significant bytes), OUTPUT_X (16 least significant bytes)
    
    0x00
    eq
    eq

    // stack: OUTPUT_X == 0

    [OUTPUT_Z_OFFSET]
    mload
    [OUTPUT_Z_OFFSET_PLUS_32]
    mload
    0xffffffffffffffffffffffffffffffff
    and
    // stack: OUTPUT_Z (32 most significant bytes), OUTPUT_Z (16 least significant bytes)
    
    0x00
    eq
    eq

    eq
    // stack: OUTPUT_X == OUTPUT_Z == 0

    [OUTPUT_Y_OFFSET]
    mload
    [OUTPUT_Y_OFFSET_PLUS_32]
    mload
    0xffffffffffffffffffffffffffffffff
    and
    // stack: OUTPUT_Y (32 most significant bytes), OUTPUT_Y (16 least significant bytes)

    0x00
    eq
    eq
    not
    // stack: OUTPUT_Y != 0, OUTPUT_X == OUTPUT_Z == 0

    eq
    // TODO is the below still the case?
    // huff bug here:  doesn't place jumpdest op at end_if label
    end_inf jumpi

    // it's the infinity point, return (0, 0) per eip 2537
    __addmodx(OUTPUT_X, ZERO_VAL, ZERO_VAL)
    __addmodx(OUTPUT_Y, ZERO_VAL, ZERO_VAL)

    [OUTPUT_X_OFFSET]
    0x60 // 96
    return
end_inf:
}

// OUTPUT_SLOT <- OUTPUT_SLOT * 2
#define macro DoubleStep() = takes(0) returns(0) {
    // copy OUTPUT_(x/y/z) to TEMP_POINT_(x/y/z)
    __addmodx(TEMP_POINT_X, OUTPUT_X, ZERO_VAL)
    __addmodx(TEMP_POINT_Y, OUTPUT_Y, ZERO_VAL)
    __addmodx(TEMP_POINT_Z, OUTPUT_Z, ZERO_VAL)

    __mulmontx(TEMP0, TEMP_POINT_Y, TEMP_POINT_Y)

    0x30
    0x1b0
    return

    __addmodx(OUTPUT_Z, TEMP0, TEMP0)
    __addmodx(OUTPUT_Z, OUTPUT_Z, OUTPUT_Z)
    __mulmontx(TEMP1, TEMP_POINT_Y, TEMP_POINT_Z)
    __mulmontx(TEMP2, TEMP_POINT_Z, TEMP_POINT_Z)
    __mulmontx(TEMP2, TEMP2, VAL_12)
    __mulmontx(OUTPUT_X, TEMP2, OUTPUT_Z)
    __mulmontx(OUTPUT_Y, TEMP0, TEMP2)
    __mulmontx(OUTPUT_Z, TEMP1, OUTPUT_Z)
    __addmodx(TEMP1, TEMP2, TEMP2)
    __addmodx(TEMP2, TEMP1, TEMP2)
    __submodx(TEMP0, TEMP0, TEMP2)
    __mulmontx(OUTPUT_Y, TEMP0, OUTPUT_Y)
    __addmodx(OUTPUT_Y, OUTPUT_X, OUTPUT_Y)
    __mulmontx(TEMP1, TEMP_POINT_X, TEMP_POINT_Y)
    __mulmontx(OUTPUT_X, TEMP0, TEMP1)
    __addmodx(OUTPUT_X, OUTPUT_X, OUTPUT_X)
}

#define fn Double() = takes(0) returns(0) {
    DoubleStep()
}

#define fn DoubleAndAdd() = takes(0) returns(0) {
    DoubleStep()

    [OUTPUT_X_OFFSET]
    0x90
    return

    AddStep()
}

#define macro CopyG1GenToOutput() = takes(0) returns(0) {
    // copy g1_gen to where we construct the output
    // TODO, just place G1_gen in the output slot
    __addmodx(OUTPUT_X, G1_GEN_X, ZERO_VAL)
    __addmodx(OUTPUT_Y, G1_GEN_Y, ZERO_VAL)
    __addmodx(OUTPUT_Z, G1_GEN_Z, ZERO_VAL)
}

#define fn DoubleAndAddWithInfCheck() = takes(0) returns(0) {
    DoubleStep()
    InfCheck() // TODO only need this (0,0) is a point on the curve. check if it is. 
    AddStep()
    InfCheck()
}

#define macro MulBy12_TEMP_2() = takes(0) returns(0) {
    // TODO compute this with multiplication
    __addmodx(TEMP5, TEMP2, TEMP2)
    __addmodx(TEMP5, TEMP5, TEMP5)
    __addmodx(TEMP2, TEMP5, TEMP5) 
    __addmodx(TEMP2, TEMP2, TEMP5) 
}

#define macro MulBy12_OUTPUT_TEMP_Y() = takes(0) returns(0) {
    // TODO compute this with multiplication
    __addmodx(TEMP5, OUTPUT_TEMP_Y, OUTPUT_TEMP_Y)
    __addmodx(TEMP5, TEMP5, TEMP5)
    __addmodx(OUTPUT_TEMP_Y, TEMP5, TEMP5) 
    __addmodx(OUTPUT_TEMP_Y, OUTPUT_TEMP_Y, TEMP5) 
}

#define constant OUTPUT_TEMP_X = 0xf // TEMP5
#define constant OUTPUT_TEMP_Y = 0x10 // TEMP6
#define constant OUTPUT_TEMP_Z = 0x11 // TEMP7
// OUTPUT_SLOT <- OUTPUT_SLOT + TEMP_POINT_SLOT
#define macro AddStep() = takes(0) returns(0) {

    // do the addition putting the output in OUTPUT_TEMP_X, OUTPUT_TEMP_Y, OUTPUT_TEMP_Z
    __mulmontx(TEMP0, OUTPUT_X, TEMP_POINT_X)
    __mulmontx(TEMP1, OUTPUT_Y, TEMP_POINT_Y)
    __mulmontx(TEMP2, OUTPUT_Z, TEMP_POINT_Z)
    __addmodx(TEMP3, OUTPUT_X, OUTPUT_Y)
    __addmodx(TEMP4, TEMP_POINT_X, TEMP_POINT_Y)
    __mulmontx(TEMP3, TEMP3, TEMP4)
    __addmodx(TEMP4, TEMP0, TEMP1)
    __submodx(TEMP3, TEMP3, TEMP4)
    __addmodx(TEMP4, TEMP_POINT_Y, TEMP_POINT_Z)
    __addmodx(OUTPUT_TEMP_X, TEMP_POINT_Y, TEMP_POINT_Z)
    __mulmontx(TEMP4, TEMP4, TEMP3)
    __addmodx(OUTPUT_TEMP_X, TEMP0, TEMP0)
    __addmodx(TEMP0, OUTPUT_TEMP_X, TEMP0)
    MulBy12_TEMP_2()
    __addmodx(OUTPUT_TEMP_Z, TEMP1, TEMP2)
    __submodx(TEMP1, TEMP1, TEMP2)
    MulBy12_OUTPUT_TEMP_Y()
    __mulmontx(OUTPUT_TEMP_X, TEMP4, OUTPUT_TEMP_Y)
    __mulmontx(TEMP2, TEMP3, TEMP1)
    __submodx(OUTPUT_TEMP_X, TEMP2, OUTPUT_TEMP_X)
    __mulmontx(OUTPUT_TEMP_Y, OUTPUT_TEMP_Y, TEMP0)
    __mulmontx(TEMP1, TEMP1, OUTPUT_Z)
    __addmodx(OUTPUT_Y, TEMP1, OUTPUT_Y)
    __mulmontx(TEMP0, TEMP0, TEMP3)
    __mulmontx(OUTPUT_Z, OUTPUT_Z, TEMP4)
    __addmodx(OUTPUT_TEMP_Z, OUTPUT_TEMP_Z, TEMP0)

    // copy the result to OUTPUT_X, OUTPUT_Y, OUTPUT_Z
    __addmodx(OUTPUT_X, OUTPUT_TEMP_X, ZERO_VAL)
    __addmodx(OUTPUT_Y, OUTPUT_TEMP_Y, ZERO_VAL)
    __addmodx(OUTPUT_Z, OUTPUT_TEMP_Z, ZERO_VAL)
}

#define macro CONVERT_OUTPUT_TO_NORM() = takes(0) returns(0) {
    __mulmontx(OUTPUT_X, OUTPUT_X, ONE_VAL)
    __mulmontx(OUTPUT_Y, OUTPUT_Y, ONE_VAL)
    __mulmontx(OUTPUT_Z, OUTPUT_Z, ONE_VAL) // TODO remove this after affine conversion is added in
}

#define macro MAIN() = takes(0) returns(0) {
    // allocate all the memory we will use
    0x00
    0x03c0
    mstore

    // store the constant 12
    0xc
    [VAL_12_OFFSET_PLUS_16]
    mstore

    // set the modulus
    0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f624
    0x00
    mstore
    //stack:

    0x1eabfffeb153ffffb9feffffffffaaab00000000000000000000000000000000
    0x20
    mstore
    //stack:

    0x06
    0x00
    setmodx
    //stack:

    // load the scalar input
    0x00
    calldataload
    //stack: scalar

    // set the G1 generator (TODO: embed this in the bytecode and copy it directly to the evmmax memory space)
    // g1_gen.x (normal form) = 0x8b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
    0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3ed
    [G1_GEN_X_OFFSET]
    mstore
    //stack: scalar

    0xd03cc744a2888ae40caa232946c5e7e100000000000000000000000000000000
    [G1_GEN_X_OFFSET_PLUS_32]
    mstore
    //stack: scalar

    // g1_gen.y (normal form) = 0x0a989badd40d6212b33cffc3f3763e9bc760f988c9926b26da9dd85e928483446346b8ed00e1de5d5ea93e354abe706c
    0x0a989badd40d6212b33cffc3f3763e9bc760f988c9926b26da9dd85e92848344
    [G1_GEN_Y_OFFSET]
    mstore
    //stack: scalar

    0x6346b8ed00e1de5d5ea93e354abe706c00000000000000000000000000000000
    [G1_GEN_Y_OFFSET_PLUS_32]
    mstore

    0x01
    [G1_GEN_Z_OFFSET]
    mstore

    [G1_GEN_X]
    dup1
    tomontx
    [G1_GEN_Y]
    dup1
    tomontx
    [G1_GEN_Z]
    dup1
    tomontx
    [VAL_12]
    dup1
    tomontx

    CopyG1GenToOutput()

    // TODO what is this offset ????
    0x01
    [ONE_VAL_OFFSET_PLUS_16]
    mstore
    //stack: scalar

    // strip off assumed-zero msb of the scalar
    0x01
    shl

    // TODO: fail explicitly when a user provides a scalar that is larger than 255 bits

    // see how big the scalar is
{% for i in range(255) %}
    dup1
    0xfe
    shr
    0x01
    and

    //TODO loop_body{{i}} rjumpi
    loop_body{{i}} jumpi

    0x01 shl
{% endfor %}

// main loop
{% for i in range(255) %}
loop_body{{i}}: // this doesn't actually have to be a jumpdest in the generated bytecode

    dup1
    0xfe
    shr
    0x00
    eq
    // is_msb_0, scalar
    // TODO: double_step_{{i}} rjumpi
    double_step_{{i}} jumpi

    // TODO call add with rjump
    // cost: push(ret_addr) + rjump + jumpi = 20
    {% if i == 254 %}
        DoubleAndAddWithInfCheck()
    {% else %}
        DoubleAndAdd()
    {% endif %}

    0x01
    shl


    //TODO: __rjump(loop_body{{i + 1}})
    {% if i == 254 %}
        end jump
    {% else %}
        loop_body{{i + 1}} jump
    {% endif %}

double_step_{{i}}:
    // TODO call add with rjump
    // cost: push(ret_addr) + rjump + jumpi = 20
    Double()
    {% if i == 254 %}
        InfCheck()
    {% endif %}
{% endfor %}

// TODO
// CONVERT_TO_AFFINE()

// convert the output to canonical form
end:
    CONVERT_OUTPUT_TO_NORM()

    [OUTPUT_X_OFFSET]
    0x90
    return
}
