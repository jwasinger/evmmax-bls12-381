#define constant G1_GEN_X = 0x0
#define constant G1_GEN_Y = 0x1
#define constant G1_GEN_Z = 0x2
#define constant OUTPUT_X = 0x3
#define constant OUTPUT_Y = 0x4
#define constant OUTPUT_Z = 0x5

#define constant SCRATCH_POINT_X = 0x6
#define constant SCRATCH_POINT_Y = 0x7
#define constant SCRATCH_POINT_Z = 0x8

#define constant TEMP0 = 0x9
#define constant TEMP1 = 0xa
#define constant TEMP2 = 0xb
#define constant TEMP3 = 0xc
#define constant TEMP3 = 0xd
#define constant TEMP4 = 0xe
#define constant TEMP5 = 0xf

#define constant G1_GEN_X_OFFSET = 0x00
#define constant G1_GEN_Y_OFFSET = 0x30
#define constant G1_GEN_Y_OFFSET_PLUS_32 = 0x50
#define constant G1_GEN_Z_OFFSET = 0x60
#define constant OUTPUT_X_OFFSET = 0x90
#define constant TEMP5_OFFSET = 0x02d0
#define constant TEMP5_OFFSET_PLUS_32 = 0x02f0

// OUTPUT_X <- OUTPUT_X / OUTPUT_Z
// OUTPUT_Y <- OUTPUT_Y / OUTPUT_Z
#define macro ToAffine() = takes(0) returns(0) {
    INVMOD_OUTPUT_Z()
    __mulmontx(OUTPUT_X, OUTPUT_X, OUTPUT_Z)
    __mulmontx(OUTPUT_Y, OUTPUT_Y, OUTPUT_Z)
}

#define macro InfCheck() = takes(0) returns(0) {
    // if OUTPUT_X == 0, OUTPUT_Y != 0, OUTPUT_Z == 0:
    //   OUTPUT <- (0, 1, 0) return (0, 0) from the contract
    OUTPUT_X_SLOT_OFFSET
    __submodx(TEMP5, OUTPUT_X, OUTPUT_Z)
    [TEMP5_OFFSET]
    mload
    [TEMP5_OFFSET_PLUS_32]
    mload
    0xffffffffffffffffffffffffffffffff
    and
    0x0
    eq
    dup2
    0x0
    eq
    eq
    //stack: mem[TEMP_SLOT_5:TEMP_SLOT_5+48] == 0

    // TODO check OUTPUT_Y != 0
    // ...
    // stack: OUTPUT_Y != 0, TEMP_SLOT_5 == 0
    eq 
    not
    end jumpi

    // it's the infinity point, return (0, 0) as per eip 2537
    __addmodx(OUTPUT_X, ZERO_VAL, ZERO_VAL)
    __addmodx(OUTPUT_Y, ZERO_VAL, ZERO_VAL)

    [OUTPUT_X_OFFSET]
    0x60 // 96
    return
end:
}

// OUTPUT_SLOT <- OUTPUT_SLOT * 2
#define macro DoubleStep() = takes(0) returns(0) {
    __mulmontx(TEMP_SLOT_0, INPUT_SLOT_Y, INPUT_SLOT_Y)
    __addmodx(OUTPUT_SLOT_Z, TEMP_SLOT_0, TEMP_SLOT_0)
    __addmodx(OUTPUT_SLOT_Z, OUTPUT_SLOT_Z, OUTPUT_SLOT_Z)
    __mulmontx(TEMP_SLOT_1, INPUT_SLOT_Y, INPUT_SLOT_Z)
    __mulmontx(TEMP_SLOT_2, INPUT_SLOT_Z, INPUT_SLOT_Z)
    __mulmontx(TEMP_SLOT_12, TEMP_SLOT_12, VAL_SLOT_12)
    __mulmontx(OUTPUT_SLOT_X, TEMP_SLOT_2, OUTPUT_SLOT_Z)
    __mulmontx(OUTPUT_SLOT_Y, TEMP_SLOT_0, TEMP_SLOT_2)
    __mulmontx(OUTPUT_SLOT_Z, TEMP_SLOT_1, OUTPUT_SLOT_Z)
    __addmodx(TEMP_SLOT_1, TEMP_SLOT_2, TEMP_SLOT_2)
    __addmodx(TEMP_SLOT_2, TEMP_SLOT_1, TEMP_SLOT_2)
    __submodx(TEMP_SLOT_0, TEMP_SLOT_0, TEMP_SLOT_2)
    __mulmontx(OUTPUT_SLOT_Y, TEMP_SLOT_0, OUTPUT_SLOT_Y)
    __addmodx(OUTPUT_SLOT_Y, OUTPUT_SLOT_X, OUTPUT_SLOT_Y)
    __mulmontx(TEMP_SLOT_1, INPUT_SLOT_X, INPUT_SLOT_Y)
    __mulmontx(OUTPUT_SLOT_X, TEMP_SLOT_0, TEMP_SLOT_1)
    __addmodx(OUTPUT_SLOT_x, OUTPUT_SLOT_X, OUTPUT_SLOT_X)
}

#define function Double() = takes(0) returns(0) {
    DoubleStep()
}

#define function DoubleAndAdd() = takes(0) returns(0) {
    DoubleStep()
    AddStep()
}

#define function DoubleAndAddWithInfCheck() = takes(0) returns(0) {
    DoubleStep()
    InfCheck() // TODO only need this (0,0) is a point on the curve. check if it is. 
    AddStep()
    InfCheck()
}

#define MulBy12_TEMP_2() = takes(0) returns(0) {
    // TODO compute this with multiplication
    __addmodx(TEMP_5, TEMP_2, TEMP_2)
    __addmodx(TEMP_5, TEMP_5, TEMP_5)
    __addmodx(TEMP_2, TEMP_5, TEMP_5) 
    __addmodx(TEMP_2, TEMP_2, TEMP_5) 
}

#define MulBy12_OUTPUT_TEMP_Y() = takes(0) returns(0) {
    // TODO compute this with multiplication
    __addmodx(TEMP_5, OUTPUT_TEMP_Y, OUTPUT_TEMP_Y)
    __addmodx(TEMP_5, TEMP_5, TEMP_5)
    __addmodx(OUTPUT_TEMP_Y, TEMP_5, TEMP_5) 
    __addmodx(OUTPUT_TEMP_Y, OUTPUT_TEMP_Y, TEMP_5) 
}

// OUTPUT_SLOT <- OUTPUT_SLOT + TEMP_POINT_SLOT
#define macro AddStep() = takes(0) returns(0) {

    // do the addition putting the output in OUTPUT_TEMP_X, OUTPUT_TEMP_Y, OUTPUT_TEMP_Z
    __mulmontx(TEMP_SLOT_0, OUTPUT_X, TEMP_POINT_X)
    __mulmontx(TEMP_SLOT_1, OUTPUT_Y, TEMP_POINT_Y)
    __mulmontx(TEMP_SLOT_2, OUTPUT_Z, TEMP_POINT_Z)
    __addmodx(TEMP_SLOT_3, OUTPUT_X, OUTPUT_Y)
    __addmodx(TEMP_4, TEMP_POINT_X, TEMP_POINT_Y)
    __mulmontx(TEMP_3, TEMP_3, TEMP_4)
    __addmodx(TEMP_4, TEMP_0, TEMP_1)
    __submodx(TEMP_3, TEMP_3, TEMP_4)
    __addmodx(TEMP_4, TEMP_POINT_Y, TEMP_POINT_Z)
    __addmodx(OUTPUT_TEMP_X, TEMP_POINT_Y, TEMP_POINT_Z)
    __mulmontx(TEMP_4, TEMP_4, TEMP_3)
    __addmodx(OUTPUT_TEMP_X, TEMP_0, TEMP_0)
    __addmodx(TEMP_0, OUTPUT_TEMP_X, TEMP_0)
    MulBy12_TEMP_2()
    __addmodx(OUTPUT_TEMP_Z, TEMP_1, TEMP_2)
    __submodx(TEMP_1, TEMP_1, TEMP_2)
    MulBy12_OUTPUT_TEMP_Y()
    __mulmontx(OUTPUT_TEMP_X, TEMP_4, OUTPUT_TEMP_Y)
    __mulmontx(TEMP_2, TEMP_3, TEMP_1)
    __submodx(OUTPUT_TEMP_X, TEMP_2, OUTPUT_TEMP_X)
    __mulmontx(OUTPUT_TEMP_Y, OUTPUT_TEMP_Y, TEMP_0)
    __mulmontx(TEMP_1, TEMP_1, OUTPUT_Z)
    __addmodx(OUTPUT_Y, TEMP_1, OUTPUT_Y)
    __mulmontx(TEMP_0, TEMP_0, TEMP_3)
    __mulmontx(OUTPUT_Z, OUTPUT_Z, TEMP_4)
    __addmodx(OUTPUT_TEMP_Z, OUTPUT_TEMP_Z, TEMP_0)

    // copy the result to OUTPUT_X, OUTPUT_Y, OUTPUT_Z
    __addmodx(OUTPUT_X, OUTPUT_TEMP_X, ZERO_VAL)
    __addmodx(OUTPUT_Y, OUTPUT_TEMP_Y, ZERO_VAL)
    __addmodx(OUTPUT_Z, OUTPUT_TEMP_Z, ZERO_VAL)
}

#define macro G1Mul() = takes(1) returns(0) {
    // TODO embed G1 generator x/y (montgomery form) in the bytecode
    0x00
    0x00
    0x60 // 96
    codedatacopy
    0x01
    [G1_GEN_Z_OFFSET]
    mstore
    __tomontx(G1_GEN_Z, G1_GEN_Z)

    [G1_GEN_X_OFFSET]
    0x04
    mstore

    // g1_gen.y = 0x0a989badd40d6212b33cffc3f3763e9bc760f988c9926b26da9dd85e928483446346b8ed00e1de5d5ea93e354abe706c
    0x0a989badd40d6212b33cffc3f3763e9bc760f988c9926b26da9dd85e92848344
    [G1_GEN_Y_OFFSET]
    mstore

    0x6346b8ed00e1de5d5ea93e354abe706c
    [G1_GEN_Y_OFFSET_PLUS_32]
    mstore

    [G1_GEN_Z_OFFSET]
    0x01
    mstore

    __tomontx(G1_GEN_X_OFFSET, G1_GEN_X_OFFSET)
    __tomontx(G1_GEN_Y_OFFSET, G1_GEN_Y_OFFSET)
    __tomontx(G1_GEN_Z_OFFSET, G1_GEN_Z_OFFSET)

    // see how big the scalar is
    dup1
    0x01
{{ for i = 0; i < 255; i++ }}
    byte
    0x01
    and

    loop_body{{i}} rjumpi
{% endfor %}

loop_start:
{% for i in range(255) %}
loop_body{{i}}: // this doesn't actually have to be a jumpdest in the generated bytecode

    // cost = 22
    shl
    dup1
    0x01
    and
    // is_lsb_1, scalar << 1
    not
    double_step_{{$i}} rjumpi

    // TODO call add with rjump
    // cost: push(ret_addr) + rjump + jumpi = 20
    {% if i == 254 %}
        DoubleAndAddWithInfCheck()
    {% else %}
        DoubleAndAdd()
    {% endif %}

    __rjump(loop_body{{i + 1}})

double_step_{{$i}}:
    // TODO call add with rjump
    // cost: push(ret_addr) + rjump + jumpi = 20
    Double()
    {% if i == 254 %}
        InfCheck()
    {% endif %}
{% endfor %}

CONVERT_TO_AFFINE()

// convert the output to canonical form
__mulmontx(OUTPUT_X, OUTPUT_X, ONE_VAL)
__mulmontx(OUTPUT_Y, OUTPUT_Y, ONE_VAL)
}
